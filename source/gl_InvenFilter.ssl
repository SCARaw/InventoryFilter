
/*******************************************************************************
        Name: Inventory Filter
        Description: The plugin filters items in the player's inventory.

            Created: sFall Script Editor
*******************************************************************************/

#define SFALL_SC_EVALUATION   (true)

#if TRACE
#define DTRACE(name)          debug_msg("Trace: " #name);
#else
#define DTRACE(name)
#endif

#define SCRIPT_VERSION        " [v2.0.4]"

#define INI_CONFIG_FILE       "\\mods\\InventoryFilter.dat\\InvenFilter.ini"
#define INI_CONFIG_FILE_SEC   INI_CONFIG_FILE "|InventoryFilter|"

#define genericCrtBox         create_object(PID_MELEE_THUG_MALE, 0, 0)

/** Возвращает максимальный подъемный вес **/
#define max_weight(obj)       get_critter_stat(obj, STAT_carry_amt)
#define dude_max_weight       max_weight(dude_obj)

/* Include Files */
#include "..\headers\itempid.h"
#include "..\headers\critrpid.h"
#include "..\headers\party.h"

#include "..\headers\sfall\define_lite.h"
#include "..\headers\sfall\command_lite.h"

#include "..\headers\sfall\sfall.h"
#include "..\headers\sfall\define_extra.h"
#include "..\headers\sfall\dik.h"

#include "iface.h"

/* Script Procedures */
procedure start;
procedure GameModeChangeHook;
procedure CreateInvenFilterLeftMenu(variable loot);
procedure CreateInvenFilterRightMenu(variable loot);
procedure DestroyFilterWin;

procedure refresh_pc_interface_slots;
procedure filter_inventory(variable filter_item_type, variable spec);
procedure filter_inventory_trader(variable filter_item_type);
procedure IsGunWeapon(variable item);
procedure IsToolGroup(variable pid);
procedure filter_inventory_sub(variable filter_item_type, variable spec_item, variable obj_ptr_1, variable obj_ptr_2);
procedure filter_remove_items(variable source_objptr, variable dest_objptr, variable item, variable item_pid);
procedure check_loot_object(variable obj);
critical procedure MoveObjectInventory(variable src_obj, variable dst_obj, variable all);
procedure MoveDudeInventory;
procedure MoveItemPCHook;
procedure MoveItemHook;
procedure BarterHook;
procedure destroy_message_win;
procedure KeyPressHook;
procedure MouseClickHook;
procedure filter_by_key(variable keyType);

procedure inven_filter_button_toggle(variable p_btn, variable spec);
procedure inven_filter_button_pressed(variable p_btn, variable filter_item_type, variable spec);
procedure inven_filter_trd_button_toggle(variable p_btn);
procedure inven_filter_trd_button_pressed(variable p_btn, variable filter_item_type);
procedure Button_Toggle_Off;

procedure SelectCreateButton(variable p_btn, variable flag);
procedure create_btn_sub;
procedure create_btn_trd_sub;
procedure Create_btn_all(variable flag, variable trd);
procedure Create_btn_armor(variable flag, variable trd);
procedure Create_btn_weapon(variable flag, variable trd);
procedure Create_btn_ammo(variable flag, variable trd);
procedure Create_btn_drug(variable flag, variable trd);
procedure Create_btn_tool(variable flag, variable trd);
procedure Create_btn_misc(variable flag, variable trd);
procedure subCreateButton(variable btn, variable flag, variable trd, variable vshift);
procedure HightlightButton(variable btn, variable flag, variable trd);
procedure DeletePressButton;
procedure DeletePressButtonTrd;
procedure subDeleteButton(variable btn, variable type, variable flag);

procedure refresh_pc_weight;
procedure weight_win(variable weight, variable type);
procedure weight_loot_win(variable obj);
procedure barter_weight_win(variable weight);
procedure party_weight_win(variable weight);
procedure print_weight(variable weight, variable maxWeight);
procedure trader_cost_win;
procedure hack_engine_weight(variable hack);

procedure GetAndSaveDudeWeight;
procedure GetDudeWeightBonus;
procedure SwappingParty(variable type, variable value);
procedure SetDudeSwapWeight(variable swapCritter);
procedure get_party_array(variable ptr_check);
procedure swap_button_pressed(variable btn);
procedure next_swap_ptr;
procedure back_swap_ptr;
procedure barter_swap_win;
procedure loot_swap_win;
procedure create_swap_win(variable x_offset, variable y_offset);
procedure swap_name(variable name);
procedure destroy_swap;

procedure CreateDropAllBtn;
procedure check_dude_equp_items(variable isSize);
critical procedure key_drop_press;
procedure key_drop_null;
procedure key_drop_release;

/* Defines */
#define item_type_tool_group     (8)

#define Explosive(x)             (x == PID_DYNAMITE) or (x == PID_PLASTIC_EXPLOSIVES) or (x == PID_ACTIVE_DYNAMITE) or (x == PID_ACTIVE_PLASTIC_EXPLOSIVE)
#define ExcludeDoctor(x)         (x != PID_FIRST_AID_KIT) and (x != PID_DOCTORS_BAG) and (x != PID_PARAMEDICS_BAG) and (x != PID_FIELD_MEDIC_KIT)
#define IncludeDoctor(x)         (x == PID_FIRST_AID_KIT) or (x == PID_DOCTORS_BAG) or (x == PID_PARAMEDICS_BAG) or (x == PID_FIELD_MEDIC_KIT)

/* Local variables which do not need to be saved */
variable begin
   iniConfig;
   sfall_version;

   interfaceX, interfaceY;
   menu_x, menu_y, x_mouse, y_mouse, posXmouse, posYmouse, r_menu_x;
   weight_win_x, weight_win_y, r_weight_win_x, weight_win_y_shift := 318;

   filterRightMenu;
   barterOutsideInterface = 1; // location of the menu outside the dialog interface
   filterMessageWin;

   enableState;
   IsCreated;

   weightIsEnabled := false;
   capsIsEnabled   := false;

   btn_all, btn_armor, btn_weapon, btn_ammo, btn_drug, btn_tool, btn_misc;
   btn_trd_all, btn_trd_armor, btn_trd_weapon, btn_trd_ammo, btn_trd_drug, btn_trd_tool, btn_trd_misc;
   btn_toggle_off;
   btn_trd_toggle_off;

   isPressed;
   special;
   sec_click;
   filterOnlyGun;
   filter_done := true;

   crtTempBoxPC; // контенер для отфильрованных предметов
   // for barter
   crtTempBoxNPC, dialogCritter;
   pcInBarter, isPartyBarter;

   // for loot
   lootObject;
   lootFilter, lootIsContainer, lootIsFriendContaner, sortFilter;

   inven_weight;
   inven_loot_weight;
   inven_party_weight;
   inven_caps;
   loot_weight;
   refresh_weight;

   pc_bTable, tr_bTable;
   smart_barter, trade_money_msg;

   // for Swapping Party
   swapIsEnabled, swapAllContainers;
   swap_contaner;    // здесь храниться предметы игрока
   swap_ptr;         // указатель на партийца, куда нужно будет возвращать предметы
   swap_party_array; // массив указателей партийцев
   len_party_array, current_swap_number := -1;

   swap_win_x, swap_win_y, swap_barter_offset, swap_barter_y_offset, swap_loot_offset, swap_loot_y_offset;

   btnDropAll, btnGiveAll, useBackImage, dropPress, drop_key_code, dropButtonWin;

   dudeBaseMaxWeight, dudeExtraMaxWeight, dudeEquipItemsWeight, dudeWeightBonus, swapMaxWeight := -1;
   partyMaxWeight, partyExtraWeightStat := -1;
   npcMaxWeight, npcExtraWeightStat = -1;
   containerMaxSize = -1;
   showPercentSize = 1;

   toolGroupPids;
   hotKeys;
   r := 0.0, g := 0.9, b := 0.2; // green
end

procedure start begin
   variable item, pid, iniConfigFile, i;

   if game_loaded then begin
      iniConfigFile := INI_CONFIG_FILE;
      iniConfig := INI_CONFIG_FILE_SEC;

      // for sFall 4.2.8+ format 4208
      sfall_version := (1000 * sfall_ver_major) + (100 * sfall_ver_minor) + sfall_ver_build;
      if ((sfall_version < 3837) orElse (sfall_version >= 4000 and sfall_version < 4208)) then begin
         display_msg(get_ini_string(iniConfig + "MsgVersion")); // Inventory фильтр требует sfall 4.2.8 или более поздней версии.
         return;
      end
      if get_ini_setting("ddraw.ini|Debugging|AllowUnsafeScripting") <= 0 then begin
         display_msg(get_ini_string(iniConfig + "MsgLoad"));
      end

      barterOutsideInterface := (get_ini_setting(iniConfig + "OldPosition") == 0);
      weightIsEnabled := get_ini_setting(iniConfig + "ShowWeight");
      capsIsEnabled := get_ini_setting(iniConfig + "ShowCaps");
      smart_barter := get_ini_setting(iniConfig + "SmartBarter");
      trade_money_msg = get_ini_string(iniConfig + "BarterCaps");

      if (weightIsEnabled) then begin
         showPercentSize := get_ini_setting(iniConfig + "PercentSize");

         //read_byte(0x477EE1) == 0x75) then hack_w_allow = true;
      end

      drop_key_code := get_ini_setting(iniConfig + "DropAllButtonKey");
      if drop_key_code < 0 then drop_key_code := 0;

      // for sFall 4.1+
      btnDropAll := get_ini_setting(iniConfig + "DropAllButton");
      btnGiveAll := get_ini_setting(iniConfig + "UseGiveAllImage");
      useBackImage := get_ini_setting(iniConfig + "UseBackImage");

      // for sFall 4.2+
      hotKeys := get_ini_section(iniConfigFile, "HotKeys");
      foreach (i : item in hotKeys) begin
         if (typeof(i) == VALTYPE_STR) then hotKeys[i] := atoi(item);
      end
      fix_array(hotKeys);

      switch (get_ini_setting(iniConfig + "TextColor")) begin
        case 1 : r := 0.72; g := 0.72; b := 0.2; // yellow
        case 2 : r := 0.90; g := 0.90; b := 0.9; // near white
      end

      register_hook_proc(HOOK_KEYPRESS, KeyPressHook);
      register_hook_proc(HOOK_MOUSECLICK, MouseClickHook);
      register_hook_proc_spec(HOOK_BARTERPRICE, BarterHook); // register_hook_proc(HOOK_BARTERPRICE, hBarter);
      register_hook_proc(HOOK_REMOVEINVENOBJ, MoveItemHook);
      register_hook_proc(HOOK_GAMEMODECHANGE, GameModeChangeHook);
      register_hook_proc(HOOK_INVENTORYMOVE, MoveItemPCHook);

      set_global_script_type(1);

      enableState := get_sfall_global_int("INV_FLTR");
      if (enableState == 0) then enableState := 1;
      if (enableState == 2) then display_msg(get_ini_string(iniConfig + "MsgInfo"));

      if (get_screen_height > 480) then begin
         swapIsEnabled := get_ini_setting(iniConfig + "SwapParty");
         if (swapIsEnabled) then begin
            swapAllContainers := get_ini_setting(iniConfig + "SwapContainers");
            swap_loot_offset := get_ini_setting(iniConfig + "SwapLootOffset");
            swap_barter_offset := get_ini_setting(iniConfig + "SwapBarterOffset");
            swap_loot_y_offset := get_ini_setting(iniConfig + "SwapLootYOffset");
            swap_barter_y_offset := get_ini_setting(iniConfig + "SwapBarterYOffset");
         end
      end

      toolGroupPids = [
         PID_STEALTH_BOY, PID_GEIGER_COUNTER, PID_MOTION_SENSOR, PID_ACTIVE_GEIGER_COUNTER, PID_ACTIVE_STEALTH_BOY,
         PID_BIG_BOOK_OF_SCIENCE, PID_DEANS_ELECTRONICS, PID_FIRST_AID_BOOK, PID_SCOUT_HANDBOOK, PID_GUNS_AND_BULLETS
      ];
      fix_array(toolGroupPids);

      variable pids = string_split(get_ini_string(iniConfig + "ToolGroupPids"), ",");
      resize_array(toolGroupPids, 10 + len_array(pids));
      i = 10;
      foreach (pid in pids) begin
         toolGroupPids[i] = atoi(pid);
         i++;
      end

      weight_win_y_shift := weight_win_y_shift + get_ini_setting(iniConfig + "WeightWinShift");

     #if DEBUG // test items
        foreach (pid in toolGroupPids) begin
            debug_msg("ToolPid: " + pid);
        end
        item_caps_adjust(dude_obj, 1000);
        add_mult_objs_to_inven(dude_obj, create_object(PID_BAG, 0, 0), 1);
        add_mult_objs_to_inven(dude_obj, create_object(PID_10MM_PISTOL, 0, 0), 10);
//        item := 50;
//        while item > 0 do begin
//           pid := random(1, 600);
//           if get_proto_data(pid, PROTO_IT_TYPE) != item_type_container then begin
//              add_mult_objs_to_inven(dude_obj, create_object(pid, 0, 0), 1);
//              item -= 1;
//           end
//        end
     #endif
   end
   else begin
      if (IsCreated) then begin
         if (weightIsEnabled) then begin // refresh weight win
            if (loot_weight andAlso lootFilter) then begin
               DTRACE("refresh weight 1")
               if (lootIsFriendContaner) then call weight_loot_win(lootObject);
               call weight_win(who_carry_amount(dude_obj), 0);
               loot_weight := false;
            end
            if (refresh_weight) then begin
               DTRACE("refresh weight 2")
               if (inven_weight) then call barter_weight_win(0);
               if (inven_party_weight) then call party_weight_win(0);
               refresh_weight := false;
            end
         end
         if (sortFilter) then call Button_Toggle_Off;
      end
   end
end

procedure GameModeChangeHook begin
   variable mode = get_game_mode;
   if (filterMessageWin andAlso (mode bwand (WORLDMAP bwor LOADGAME) or get_sfall_arg)) then call destroy_message_win;
   if (enableState == 2) then return;

   if (mode bwand (INTFACEUSE bwor INVENTORY bwor BARTER bwor INTFACELOOT)) then begin
      lootFilter = mode bwand INTFACELOOT;

      if not(IsCreated) then begin
         IsCreated := true;
         call CreateInvenFilterLeftMenu(lootFilter);
         if (lootIsFriendContaner orElse (mode bwand BARTER)) then begin
            call CreateInvenFilterRightMenu(lootFilter);
         end
      end
   end
   else if (IsCreated) then begin
      call DestroyFilterWin;
   end
end

procedure CreateInvenFilterLeftMenu(variable isLoot) begin
   DTRACE("CreateInvenFilterLeftMenu")

   variable mode = get_game_mode;
   if (mode bwand BARTER) then begin
      interfaceX = get_interface_x(WINTYPE_DIALOG);
      interfaceY = get_interface_y(WINTYPE_DIALOG);
      if (barterOutsideInterface) then begin
         menu_x = interfaceX - menu_width;
         menu_y = interfaceY + 480 - menu_heigh;
      end
      else begin
         menu_x = interfaceX + 10;
         menu_y = interfaceY + 100;
      end
   end
   else begin // for PC/USE/LOOT inventory
      interfaceX = get_interface_x(WINTYPE_INVENTORY);
      interfaceY = get_interface_y(WINTYPE_INVENTORY);
      menu_x = interfaceX - menu_width;
      menu_y = interfaceY;
      if (menu_x < 0) then menu_x := 0;

      if (isLoot) then begin
         lootObject = loot_obj;
         lootIsContainer = (obj_item_subtype(lootObject) == item_type_container);
         sortFilter = (lootIsContainer == false) andAlso (party_member_obj(obj_pid(lootObject)) == 0);
      end
   end

   // создание окна
   createWin("inven_filter", menu_x, menu_y, menu_width, menu_heigh);
   selectWin("inven_filter");
   Display(mainPCXFile);

   if (sortFilter == false) then call Create_btn_all("on", 0);
   call Create_btn_armor("off", 0);
   call Create_btn_weapon("off", 0);
   call Create_btn_ammo("off", 0);
   call Create_btn_drug("off", 0);
   call Create_btn_tool("off", 0);
   call Create_btn_misc("off", 0);

   showWin;

   if (weightIsEnabled andAlso mode bwand INVENTORY) then begin
      weight_win_x = interfaceX + 48;
      weight_win_y = interfaceY + weight_win_y_shift;
   end

   if (isLoot) then begin
      lootIsFriendContaner = check_loot_object(lootObject);
      if (lootIsContainer) then begin
         containerMaxSize = get_proto_data(obj_pid(lootObject), PROTO_CN_MAX_SIZE);
      end
      if (weightIsEnabled) then begin
         loot_weight := true; // включает отображение окна с весом для LOOT
         weight_win_x = interfaceX + 48;
         weight_win_y = interfaceY + 120;
         r_weight_win_x = interfaceX + 426;
      end
      if (btnDropAll) then begin
         if (useBackImage) then begin
            interface_art_draw(WINTYPE_INVENTORY, "PCX\\InvFilterArt\\DropAll_Back.pcx", 63, 188);
         end
         /*if (lootIsFriendContaner) then*/ call CreateDropAllBtn;
      end
   end
   if ((mode bwand INTFACEUSE) == false andAlso (weightIsEnabled orElse sortFilter)) then set_global_script_repeat(1);

   if (mode bwand BARTER) then begin
      weight_win_x = interfaceX + 20;
      weight_win_y = interfaceY + 398;
      r_weight_win_x = interfaceX + 562;

      dialogCritter = dialog_obj;
      if swapIsEnabled then call barter_swap_win;
      if weightIsEnabled then call barter_weight_win(0);
   end
   else if (swapIsEnabled andAlso isLoot andAlso (swapAllContainers orElse lootObject == Trunk_Ptr)) then begin
      if (lootIsFriendContaner) then call loot_swap_win;
   end

   btn_all    := not(sortFilter);
   btn_armor  := false;
   btn_weapon := false;
   btn_ammo   := false;
   btn_drug   := false;
   btn_tool   := false;
   btn_misc   := false;
   special    := false;
end

procedure CreateInvenFilterRightMenu(variable isLoot) begin
   DTRACE("CreateInvenFilterRightMenu")

   // параметры окна
   if (isLoot) then begin
      r_menu_x := interfaceX + 537; // for Loot
   end
   else begin
      // for Barter
      if (barterOutsideInterface) then
         r_menu_x := interfaceX + 640;
      else
         r_menu_x := interfaceX + 630 - menu_width;
   end

   //создание окна
   createWin("inven_filter_trd", r_menu_x, menu_y, menu_width, menu_heigh);
   selectWin("inven_filter_trd");
   display(mainPCXFile);

   if (sortFilter == false) then call Create_btn_all("on", 1);
   call Create_btn_armor("off", 1);
   call Create_btn_weapon("off", 1);
   call Create_btn_ammo("off", 1);
   call Create_btn_drug("off", 1);
   call Create_btn_tool("off", 1);
   call Create_btn_misc("off", 1);

   showWin;

   if (isLoot == false) then begin
      isPartyBarter := party_member_obj(obj_pid(dialogCritter)) != 0;

      if (weightIsEnabled andAlso isPartyBarter) then begin
         partyMaxWeight := max_weight(dialogCritter);
         call party_weight_win(0);
      end
   end

   btn_trd_all    := not(sortFilter);
   btn_trd_armor  := false;
   btn_trd_weapon := false;
   btn_trd_ammo   := false;
   btn_trd_drug   := false;
   btn_trd_tool   := false;
   btn_trd_misc   := false;

   filterRightMenu = true;
end

procedure DestroyFilterWin begin
   debug_msg("Inventory filter windows destroy.");

   set_global_script_repeat(0);
   IsCreated := false;
   deleteWin("inven_filter");

   if crtTempBoxPC then begin
      move_obj_inven_to_obj(crtTempBoxPC, dude_obj);
      destroy_object(crtTempBoxPC);
   end

   if (dropButtonWin) then begin
      deleteWin("drop_win");
      dropButtonWin := false;
   end

   if (filterRightMenu) then begin
      if (lootFilter) then begin
          lootIsFriendContaner := false;
          if (crtTempBoxNPC) then move_obj_inven_to_obj(crtTempBoxNPC, lootObject);
          if (dialogCritter) then destroy_object(dialogCritter);
          if (containerMaxSize != -1) then begin
             set_proto_data(obj_pid(lootObject), PROTO_CN_MAX_SIZE, containerMaxSize);
             containerMaxSize = -1;
          end
      end
      else begin
          if (crtTempBoxNPC) then move_obj_inven_to_obj(crtTempBoxNPC, dialogCritter);
          if inven_caps then deleteWin("inven_caps");
          inven_caps := false;
          tr_bTable := 0;
          pc_bTable := 0;

          if (isPartyBarter) then begin
            if (partyExtraWeightStat != -1) then begin
               debug_msg("Filter: Restore party member carry stat.");
               set_critter_extra_stat(dialogCritter, STAT_carry_amt, partyExtraWeightStat);
               partyExtraWeightStat = -1;
            end
            if inven_party_weight then deleteWin("inven_party_weight");
            inven_party_weight := false;
          end
      end
      if (swapMaxWeight != -1) then begin
         debug_msg("Filter: Restore dude carry stats.");
         set_pc_base_stat(STAT_carry_amt, dudeBaseMaxWeight);
         set_pc_extra_stat(STAT_carry_amt, dudeExtraMaxWeight);
         swapMaxWeight := -1;
      end
      if (npcExtraWeightStat != -1) then begin
         debug_msg("Filter: Restore critter carry stat.");
         set_critter_extra_stat(lootObject, STAT_carry_amt, npcExtraWeightStat);
         npcExtraWeightStat = -1;
      end
      if (crtTempBoxNPC) then destroy_object(crtTempBoxNPC);
      deleteWin("inven_filter_trd");
      btn_trd_all := true;
      pcInBarter := false;
      if (swapIsEnabled andAlso current_swap_number > -1) then call destroy_swap;
      filterRightMenu = false;
   end

   if (inven_weight) then deleteWin("inven_weight");
   if (inven_loot_weight) then deleteWin("inven_loot_weight");

   sortFilter = false;
   inven_loot_weight := false;
   inven_weight := false;
   crtTempBoxPC := 0;
   crtTempBoxNPC := 0;
   dialogCritter := 0;
   filterOnlyGun := false;
   //if (_hack_weight) then call hack_engine_weight(false);
end

inline procedure refresh_pc_interface_slots begin
   inventory_redraw(0);
end

procedure filter_inventory(variable filter_item_type, variable spec) begin
variable item, spec_item := -1,
         crttr, weight;

   DTRACE("filter_inventory")

   filter_done := false;

   if (spec == 1) then begin
      if filter_item_type == item_type_ammo then
         spec_item := item_type_weapon;
      else
         spec_item := item_type_ammo;
   end
   else if (spec == 2) then begin
      spec_item = item_type_weapon;
   end

   // создать криттера в качестве временного контенера для перемещения отфильрованных предметов
   if crtTempBoxPC == 0 then
      crtTempBoxPC := genericCrtBox;
   else
      move_obj_inven_to_obj(crtTempBoxPC, dude_obj);

   if filter_item_type != (-1) then weight := filter_inventory_sub(filter_item_type, spec_item, dude_obj, crtTempBoxPC);

   //показывать деньги сверху в режиме бартера при выборе категории ALL/MISC
   if (filter_item_type == (-1) or filter_item_type == item_type_misc_item) and not(get_game_mode bwand INTFACELOOT) then begin
      item := obj_carrying_pid_obj(dude_obj, PID_BOTTLE_CAPS);
      if item != 0 then begin
         call filter_remove_items(dude_obj, dude_obj, item, PID_BOTTLE_CAPS);
      end
   end

   if (pcInBarter or lootFilter) then begin
      if (sortFilter) then begin // принцип сортировки для LOOT интерфейса
        // перемещаем инвентарь dude в инвентарь временного криттера (решение бага с надетой броней, когда применяется функция move_obj_inven_to_obj характеристики брони уходят в минуса)
        crttr := MoveDudeInventory;  // TODO - Требуется протестировать этот баг на напарниках, возможно он также имеется.

        move_obj_inven_to_obj(crtTempBoxPC, dude_obj);
        move_obj_inven_to_obj(crttr, dude_obj);
        destroy_object(crttr);
      end
      else begin // for dude_in_barter
         // сохраняем статы веса игрока если еще не были сохранены
         if (swapMaxWeight == -1) then call GetAndSaveDudeWeight;

         // уменьшаем максимальный вес PC, для того чтобы игрок не смог превысить допустимый переносимый вес
         weight := who_carry_amount(crtTempBoxPC); // вес отфильтрованных предметов
         set_pc_base_stat(STAT_carry_amt, dudeWeightBonus); // учитываем возможный -/+ бонус у игрока

         // проверить ведется ли свап обмен
         if (swap_ptr and swap_ptr != dude_obj) then begin
            weight += who_carry_amount(swap_ptr); // + экипировка криттера
            set_pc_extra_stat(STAT_carry_amt, max_weight(swap_ptr) - weight + dudeEquipItemsWeight);
         end
         else begin
            set_pc_extra_stat(STAT_carry_amt, swapMaxWeight - weight);
         end
      end
      call refresh_pc_interface_slots;
   end
   else begin
      if (get_game_mode bwand INVENTORY) then begin
         if not(weightIsEnabled) then begin
//            if (hack_w_allow) then begin
//               if (_hack_weight == false and filter_item_type != (-1)) then
//                  call hack_engine_weight(true);
//               else if (filter_item_type == (-1)) then
//                  call hack_engine_weight(false);
//            end
         end else call weight_win(weight, filter_item_type);
         display_stats;
      end
      tap_key(DIK_HOME);
   end
   filter_done := true;
   filterOnlyGun = false;
end

procedure filter_inventory_trader(variable filter_item_type) begin
variable item;

   DTRACE("filter_inventory_trader")

   // перемещаем инвентарь контейнера в инвентарь криттера
   if lootFilter then begin
      filter_done := false;
      if dialogCritter == 0 then dialogCritter := genericCrtBox;
      move_obj_inven_to_obj(lootObject, dialogCritter);
   end

   if (crtTempBoxNPC == 0) then
      crtTempBoxNPC := genericCrtBox;
   else
      move_obj_inven_to_obj(crtTempBoxNPC, dialogCritter);

   if (filter_item_type != (-1)) then call filter_inventory_sub(filter_item_type, -1, dialogCritter, crtTempBoxNPC);

   //показывать деньги сверху в режиме бартера
   if (get_game_mode bwand DIALOG) and (filter_item_type == item_type_misc_item or filter_item_type == (-1)) then begin
      item := obj_carrying_pid_obj(dialogCritter, PID_BOTTLE_CAPS);
      if (item != 0) then call filter_remove_items(dialogCritter, dialogCritter, item, PID_BOTTLE_CAPS);
   end

   // принцип сортировки для LOOT интерфейса
   if (lootFilter) then begin
       if (sortFilter) then move_obj_inven_to_obj(crtTempBoxNPC, lootObject); //возвращаем инвентарь в контейнер
       move_obj_inven_to_obj(dialogCritter, lootObject);
       filter_done := true;

       // уменьшаем максимальный вес, для того что бы игрок не смог превысить допустимый переносимый вес
       if (sortFilter == false) then begin
          if (lootIsContainer) then begin
             set_proto_data(obj_pid(lootObject), PROTO_CN_MAX_SIZE, containerMaxSize - get_current_inven_size(crtTempBoxNPC));
          end
          else begin
            if (npcExtraWeightStat == -1) then begin
               npcExtraWeightStat = get_critter_extra_stat(lootObject, STAT_carry_amt);
               npcMaxWeight = max_weight(lootObject);
            end
            set_critter_extra_stat(lootObject, STAT_carry_amt, npcExtraWeightStat - who_carry_amount(crtTempBoxNPC)); // отнимаем вес отфильтрованных предметов
          end
       end
   end
   else if (isPartyBarter) then begin
      // уменьшаем максимальный вес, для того что бы игрок не смог превысить допустимый переносимый вес
      if (partyExtraWeightStat == -1) then partyExtraWeightStat := get_critter_extra_stat(dialogCritter, STAT_carry_amt);
      set_critter_extra_stat(dialogCritter, STAT_carry_amt, partyExtraWeightStat -  who_carry_amount(crtTempBoxNPC)); // отнимаем вес отфильтрованных предметов
   end

   inventory_redraw(1);
end

procedure IsGunWeapon(variable pid) begin
   variable wAnim = get_proto_data(pid, PROTO_WP_ANIM);
   return (wAnim >= WPN_ANIM_PISTOL andAlso wAnim <= WPN_ANIM_ROCKET_LAUNCHER);
end

procedure IsToolGroup(variable ipid) begin
   variable pid;
   foreach (pid in toolGroupPids) begin
      if (pid == ipid) then return true;
   end
   return false;
end

procedure filter_inventory_sub(variable filter_item_type, variable spec_item, variable source_objptr, variable dest_objptr) begin
variable item_pid, item, weight, remove,
         item_counter := 0,
         prev_counter := 0;

   item := inven_ptr(source_objptr, item_counter);
   while (item and item_counter < 1000) do begin
      item_pid := obj_pid(item);
      //в режиме торговли если предмет деньги то остаются в инвентаре игрока.
      if (item_pid != PID_BOTTLE_CAPS or (get_game_mode bwand (INVENTORY bwor INTFACEUSE bwor INTFACELOOT))) then begin
         if filter_item_type < item_type_misc_item then begin
            if filter_item_type == item_type_drug then begin
               //не исключаются drugs
               if (obj_item_subtype(item) != item_type_drug) then begin
                  call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
               end
               else item_counter++;
            end
            else begin
               remove = true;

               variable type = obj_item_subtype(item);
               if (type == filter_item_type orElse type == spec_item) then begin // не исключаются предметы тип которых соответствует фильтру
                  // onlyGun - оставлять оружие типа GUNS, когда
                  variable onlyGun = filterOnlyGun orElse (filter_item_type == spec_item andAlso filter_item_type == item_type_weapon);
                  if (onlyGun == false orElse IsGunWeapon(item_pid)) then remove = false; // не удалять
               end

               if (remove) then
                  call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
               else item_counter++;
            end
         end
         else begin
            if (filter_item_type == item_type_tool_group) then begin
               if (IsToolGroup(item_pid) or IncludeDoctor(item_pid) or Explosive(item_pid) or obj_item_subtype(item) == item_type_container) then
                  item_counter++; // неисключаются полезные вещи из категории misc
               else
                  call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
            end
            else if (filter_item_type == item_type_misc_item) then begin
               type = obj_item_subtype(item);
               if (type > item_type_misc_item or (type == item_type_misc_item andAlso
                   ExcludeDoctor(item_pid) andAlso not(Explosive(item_pid)) andAlso not(IsToolGroup(item_pid)) ))
               then
                  item_counter++; // не исключаются misc и key
               else begin
                  call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
               end
            end
         end

         if (weightIsEnabled and (item_counter > prev_counter)) then begin // если больше то считаем вес этого предмета
            weight += item_weight(item) * obj_is_carrying_obj(dude_obj, item);

//            if enable_weight and obj_item_subtype(item) == item_type_weapon then
//               weight += call_offset_r1(0x477B88, item) * items;  /* Engine get weight for weapon */
//            else if (armor_engine_weight(item_pid)) then
//               weight += (proto_data(item_pid, it_weight) / 2) * items;
//            else
//               weight += proto_data(item_pid, it_weight) * items;

            prev_counter := item_counter;
         end
      end
      else begin
         item_counter++;
         prev_counter++;
      end
      item := inven_ptr(source_objptr, item_counter);
   end
   return weight;
end

procedure filter_remove_items(variable source_objptr, variable dest_objptr, variable item, variable item_pid) begin
   variable items := rm_mult_objs_from_inven(source_objptr, item, obj_is_carrying_obj(source_objptr, item));
   //debug_msg("item remove count " + count + " removed " + items);

   // обход бага в функции add_mult_objs_to_inven для монет если количество превышает 99999
   if (item_pid == PID_BOTTLE_CAPS) then
      item_caps_adjust(dest_objptr, items);
   else
      add_mult_objs_to_inven(dest_objptr, item, items);

end

// Возарвщает True если объект является контенером или членом группы
procedure check_loot_object(variable obj) begin
   variable objtype = obj_item_subtype(obj);
   if (objtype != item_type_container) then begin
      return is_in_array(obj, party_member_list_critters); // проверка на обмен с партийцем
   end
   return true;
end

procedure MoveObjectInventory(variable src_obj, variable dst_obj, variable all) begin
   variable flags, item_ptr, pid, slot;

   item_ptr := inven_ptr(src_obj, slot);
   while item_ptr do begin
      pid := obj_pid(item_ptr);
      if (all or pid != PID_BOTTLE_CAPS) then begin //loot_filter
         flags := get_flags(item_ptr);
         if not(flags bwand (FLAG_LEFT_HAND bwor FLAG_RIGHT_HAND bwor FLAG_WORN)) then
            call filter_remove_items(src_obj, dst_obj, item_ptr, pid);
         else slot++;
      end else slot++;
      item_ptr := inven_ptr(src_obj, slot);
   end
end

procedure MoveDudeInventory begin
   variable item_ptr, crtr := genericCrtBox;

   item_ptr := inven_ptr(dude_obj, 0);
   while item_ptr do begin
      call filter_remove_items(dude_obj, crtr, item_ptr, obj_pid(item_ptr));
      item_ptr := inven_ptr(dude_obj, 0);
   end
   return crtr;
end

procedure MoveItemPCHook begin
   if (inven_weight) then begin
      if (pcInBarter) then begin
         call barter_weight_win(-item_weight(get_sfall_arg_at(1)));
      end
      else call refresh_pc_weight in 0; // делает небольшую задержку, чтобы правильно обновить вес
   end
end

procedure MoveItemHook begin
/*
   critter arg1 - the critter the object is being removed from
   item    arg2 - the item that is being removed
   int     arg3 - a flag, or possibly the number of items to remove
   int     arg4 - The reason the object is being removed. (Actually, the site from which _item_remove_mult was called)
*/
   variable obj, item, count; //weight;

   if (enableState == 2) then return;

   if (weightIsEnabled and lootFilter and filter_done and not(loot_weight)) then begin
      loot_weight := true;
      return;
   end

   // обновление веса в инвентаре игрока
   if (filter_done and inven_weight and get_game_mode bwand INVENTORY) then begin
      call refresh_pc_weight in 0; // делает небольшую задержку, чтобы правильно обновить вес
   end

   if (inven_weight == false or pcInBarter == false) then return;

   obj := get_sfall_arg;
   if (obj != dude_obj and obj != pc_bTable and obj != dialogCritter and obj != tr_bTable) then return;

   item  := get_sfall_arg;
   count := get_sfall_arg;

   // flag
   if get_sfall_arg == RMOBJ_TRADE then begin
      DTRACE("hMoveItem RMOBJ_TRADE")

      refresh_weight := true;
/*
      weight := call_offset_r1(0x477B88, item) * count; // item_weight_
      if (obj == dude_obj or obj == pc_bTable) then begin
         if (obj == dude_obj) then weight := -weight;
      end
      else if (obj != dialogCritter) then begin
          weight := -weight;
      end
      call barter_weight_win(weight);

      if (inven_party_weight) then begin
         weight := -weight; // инвертирование знака веса
         call party_weight_win(weight);
      end
*/
   end
end

procedure BarterHook begin
/*
   critter arg0 - the critter doing the bartering (either dude_obj or inven_dude)
   critter arg1 - the critter being bartered with
   int     arg2 - общая стоимость предложенных товаров у тоговца (the default value of the goods)
   critter arg3 - the barter critter (has all of the goods being traded in its inventory)
   int     arg4 - the amount of actual caps in the barter stack (as opposed to goods)
   int     arg5 - цена всех товаров (the value of all goods being traded before skill modifications)
   +
   critter arg6 - указатель на "стол" с предложенными игроком товарами
   int     arg7 - общая стоимость предложенных игроком товаров (отдельно можно узнать количество денег с помощью item_caps_total(arg7))
   int     arg8 - 1 если была нажата кнопка "предложения обмена" не сопартийцу, иначе 0.
*/
   variable barter_args, caps, diff, playerCost;

   if (enableState == 2) then return;
   barter_args := get_sfall_args;

   if (pcInBarter == false) then begin
      pcInBarter := true;
      dialogCritter := barter_args[1]; // на всякий случай
      tr_bTable := barter_args[3];
      pc_bTable := barter_args[6];
   end

   if (smart_barter and barter_args[8] and party_member_obj(obj_pid(dialogCritter)) == 0) then begin
      diff := barter_args[2] - barter_args[7]; // разница цены в предложенных товарах, отрицательное - задолженность для торговца
      if (diff < 0) then begin
         caps := item_caps_total(dialogCritter);
         if (caps > 0) then begin
            if (0 - diff) > caps then diff := 0 - caps;
         end else diff := 0;
      end
      else if (item_caps_total(pc_bTable) == 0 or item_caps_total(dude_obj) < diff) then diff := 0;

      if (diff != 0) then begin
         item_caps_adjust(dude_obj, -diff);
         item_caps_adjust(dialogCritter, diff);
         if (diff > 0 and trade_money_msg) then display_msg(sprintf(trade_money_msg, diff));

         playerCost := barter_args[7];
         set_sfall_arg(2, playerCost);
         set_sfall_return(playerCost); // возвращаем цену для торговца равную общей стоимости товаров игрока
      end
   end
   if (capsIsEnabled andAlso isPartyBarter == false) then call trader_cost_win;
end

procedure destroy_message_win begin
   if (filterMessageWin) then DeleteWin("filter_msg");
   filterMessageWin = false;
end

procedure KeyPressHook begin
variable type  := get_sfall_arg, // event type: 1 - pressed, 0 - released
         key   := get_sfall_arg,
         text;

   if key == DIK_F11 and type == 0 and get_game_mode == 0 then begin
      if (enableState == 1) then begin
         text = get_ini_string(iniConfig + "MsgOff"); //"Inventory Filter is disabled."
      end else begin
         text = get_ini_string(iniConfig + "MsgOn") + SCRIPT_VERSION; //"Inventory Filter is enabled."
      end

      SetFont(101);
      variable w = get_text_width(text) + 10;
      create_win_flag("filter_msg", get_screen_width - w - 5, 10, w, 15, WIN_FLAG_TRANSPARENT);
      SelectWin("filter_msg");
      GotoXY(2, 2);
      SetTextColor(1.0, 1.0, 1.0);
      SetTextFlags(textnofill bwor textshadow); // default
      Print(text);
      ShowWin;

      filterMessageWin = true;
      enableState++;
      if (enableState > 2) then enableState := 1;
      set_sfall_global("INV_FLTR", enableState);

      call destroy_message_win in 3;
   end
   else if ((enableState == 1) and IsCreated) then begin
      if (key == drop_key_code and (get_game_mode bwand INTFACELOOT)) then begin
         if (type == 1) then call key_drop_press;
         if (type == 0) then call key_drop_release;
      end
      else if (type == 1 andAlso (get_game_mode bwand COUNTERWIN) == false) then begin
         variable i, hotKey;
         foreach (i : hotKey in hotKeys) begin
            if (key == hotKey) then begin
               call filter_by_key(i);
               break;
            end
         end
      end
      if (type == 0 andAlso isPressed) then isPressed := false;
   end
end

procedure MouseClickHook begin
variable type, button;

   if ((enableState == 1) andAlso (get_game_mode bwand (INVENTORY bwor INTFACEUSE bwor INTFACELOOT bwor BARTER))) then begin

      type   := get_sfall_arg;   // event type: 1 - pressed, 0 - released
      button := get_sfall_arg;   // button number (0 - left, 1 - right, up to 7)

      posXmouse := get_mouse_x;
      posYmouse := get_mouse_y;

      if (button == 0) then begin
         if (type == 1) then begin
             x_mouse := get_mouse_x;
             y_mouse := get_mouse_y;
         end

         if (type) then begin
            if inven_filter_button_all and not(btn_all) and not(sortFilter) then            // button all no filter
               call inven_filter_button_pressed("all", -1, 0);
            else if inven_filter_button_armor and not(btn_armor) then                       // button armor
               call inven_filter_button_pressed("armor", item_type_armor, 0);
            else if inven_filter_button_weapon and not(btn_weapon) then  begin              // button weapon
               call inven_filter_button_pressed("weapon", item_type_weapon, 0);
               sec_click := true;
            end
            else if inven_filter_button_ammo and not(btn_ammo) then                         // button ammo
               call inven_filter_button_pressed("ammo", item_type_ammo, 0);
            else if inven_filter_button_drug and not(btn_drug) then                         // button drug
               call inven_filter_button_pressed("drug", item_type_drug, 0);
            else if inven_filter_button_tool and not(btn_tool) then                         // button tool
               call inven_filter_button_pressed("tool", item_type_tool_group, 0);
            else if inven_filter_button_misc and not(btn_misc) then                         // button misc
               call inven_filter_button_pressed("misc", item_type_misc_item, 0);
            // for trader/loot
            else if (filterRightMenu) then begin
               if inven_filter_trd_button_all and not(btn_trd_all) and not(sortFilter) then // button all no filter
                  call inven_filter_trd_button_pressed("all", -1);
               else if inven_filter_trd_button_armor and not(btn_trd_armor) then            // button armor
                  call inven_filter_trd_button_pressed("armor", item_type_armor);
               else if inven_filter_trd_button_weapon and not(btn_trd_weapon) then          // button weapon
                  call inven_filter_trd_button_pressed("weapon", item_type_weapon);
               else if inven_filter_trd_button_ammo and not(btn_trd_ammo) then              // button ammo
                  call inven_filter_trd_button_pressed("ammo", item_type_ammo);
               else if inven_filter_trd_button_drug and not(btn_trd_drug) then              // button drug
                  call inven_filter_trd_button_pressed("drug", item_type_drug);
               else if inven_filter_trd_button_tool and not(btn_trd_tool) then              // button tool
                  call inven_filter_trd_button_pressed("tool", item_type_tool_group);
               else if inven_filter_trd_button_misc and not(btn_trd_misc) then              // button mis
                  call inven_filter_trd_button_pressed("misc", item_type_misc_item);
            end

            if (swapIsEnabled andAlso (lootIsFriendContaner orElse pcInBarter) andAlso current_swap_number > -1) then begin
               if swap_next_button then
                  call swap_button_pressed(true);
               else if swap_back_button then
                  call swap_button_pressed(false);
            end
         end
      end // клик средней кнопкой мышки по кнопкам патроны или оружие
      else if (button == 2) then begin
          if (btn_ammo orElse btn_weapon) then begin
             if inven_filter_button_ammo and not(btn_ammo) then                             // button ammo
                call inven_filter_button_pressed("ammo", item_type_ammo, 1);
             else if inven_filter_button_weapon and not(btn_weapon) then                    // button weapon
                call inven_filter_button_pressed("weapon", item_type_weapon, 1);
          end
          if inven_filter_button_weapon and (not(btn_weapon) or sec_click) then begin       // button misc
             call inven_filter_button_pressed("weapon", item_type_weapon, 2);
             sec_click := false;
             filterOnlyGun = true;
          end
      end
      if (isPressed andAlso type == 0) then isPressed := false;
   end
end

procedure filter_by_key(variable keyType) begin
   if (keyType[0] == "n" andAlso (pcInBarter orElse lootFilter) == false) then return;

   switch (keyType) begin
      case "pAll":
         if not(btn_all) and not(sortFilter) then call inven_filter_button_pressed("all", -1, 0);
      case "pArmor":
         if not(btn_armor) then call inven_filter_button_pressed("armor", item_type_armor, 0);
      case "pWeapon":
         if not(btn_weapon) then begin
            call inven_filter_button_pressed("weapon", item_type_weapon, 0);
            sec_click := true;
         end
         else if (sec_click) then begin
           call inven_filter_button_pressed("weapon", item_type_weapon, 2);
           filterOnlyGun = true;
           sec_click := false;
         end
      case "pAmmo":
         if not(btn_ammo) then call inven_filter_button_pressed("ammo", item_type_ammo, 0);
      case "pDrug":
         if not(btn_drug) then call inven_filter_button_pressed("drug", item_type_drug, 0);
      case "pMisc":
         if not(btn_tool) then
            call inven_filter_button_pressed("tool", item_type_tool_group, 0);
         else if (btn_tool) then begin
            call inven_filter_button_pressed("misc", item_type_misc_item, 0);
         end
      // for trader/loot
      case "nAll":
         if not(btn_trd_all) and not(sortFilter) then call inven_filter_trd_button_pressed("all", -1);
      case "nArmor":
         if not(btn_trd_armor) then call inven_filter_trd_button_pressed("armor", item_type_armor);
      case "nWeapon":
         if not(btn_trd_weapon) then call inven_filter_trd_button_pressed("weapon", item_type_weapon);
      case "nAmmo":
         if not(btn_trd_ammo) then call inven_filter_trd_button_pressed("ammo", item_type_ammo);
      case "nDrug":
         if not(btn_trd_drug) then call inven_filter_trd_button_pressed("drug", item_type_drug);
      case "nMisc":
         if not(btn_trd_tool) then
            call inven_filter_trd_button_pressed("tool", item_type_tool_group);
         else if (btn_trd_tool) then begin
            call inven_filter_trd_button_pressed("misc", item_type_misc_item);
         end
   end
end

procedure inven_filter_button_pressed(variable p_btn, variable filter_item_type, variable spec) begin
   if not(isPressed) then begin
      isPressed := true;

      //call_offset_v2(0x476394, 2500, 0); //функция закрыть открытую сумку? первый равен 2500 для _curr_stack или 2501 для _target_curr_stack, второй указывает режим — 0 (INVENTORY), 1 (INTFACEUSE), 2 (INTFACELOOT) и 3 (BARTER)
      if (read_int(0x59E96C) > 0) then begin // проверить открыты ли сумки
        play_sfx("IISXXXX1");
        variable text := get_ini_string(iniConfig + "MsgWarning");
        if not(pcInBarter) then create_message_window(text); else display_msg(text);
      end
      else begin
        play_sfx("IB2P1XX1");
        call inven_filter_button_toggle(p_btn, spec);  //button down so highlight!
        call filter_inventory(filter_item_type, spec);
      end
   end
end

procedure inven_filter_button_toggle(variable p_btn, variable spec) begin
   if (sortFilter) then btn_toggle_off := true;

   selectWin("inven_filter");
   if not((spec == 1) and (btn_ammo or btn_weapon)) then begin
      call create_btn_sub;

      if (special) then begin
         call DeletePressButton;
         call Create_btn_ammo("off", 0);
         special := false;
      end
   end
   else special := true;

   call SelectCreateButton(p_btn, false);
   showWin;
end

procedure inven_filter_trd_button_pressed(variable p_btn, variable filter_item_type) begin
variable _target_curr_stack, text;

   if not(isPressed) then begin
       isPressed := true;

       _target_curr_stack := read_int(0x59E948);  // проверить открыты ли сумки у цели
       if _target_curr_stack > 0 then begin
           play_sfx("IISXXXX1");
           text := get_ini_string(iniConfig + "MsgWarning");
           if lootFilter then create_message_window(text); else display_msg(text);
       end
       else begin
         play_sfx("IB2P1XX1");
         call inven_filter_trd_button_toggle(p_btn);  //button down so highlight!
         call filter_inventory_trader(filter_item_type);
       end
   end
end

procedure inven_filter_trd_button_toggle(variable p_btn) begin
   if sortFilter then btn_trd_toggle_off := true;

   selectWin("inven_filter_trd");

   call create_btn_trd_sub;
   call SelectCreateButton(p_btn, true);

   showWin;
end

procedure Button_Toggle_Off begin
   if get_mouse_buttons == 0 then begin
      if btn_toggle_off then begin
         btn_toggle_off := false;
         selectWin("inven_filter");
         call create_btn_sub;
         showWin;
      end
      else if btn_trd_toggle_off then begin
         btn_trd_toggle_off := false;
         selectWin("inven_filter_trd");
         call create_btn_trd_sub;
         showWin;
      end
   end
end

/////////////////////////////////////// INTERFACE ///////////////////////////////////////////

procedure SelectCreateButton(variable p_btn, variable flag) begin
   //удалить кнопку которая была нажата
   call subDeleteButton(p_btn, "off", flag);

   // создать новую кнопку которая была нажата.
   switch p_btn begin
      case "all"    : call Create_btn_all("on", flag);
      case "armor"  : call Create_btn_armor("on", flag);
      case "weapon" : call Create_btn_weapon("on", flag);
      case "ammo"   : call Create_btn_ammo("on", flag);
      case "drug"   : call Create_btn_drug("on", flag);
      case "tool"   : call Create_btn_tool("on", flag);
      case "misc"   : call Create_btn_misc("on", flag);
   end
end

procedure create_btn_sub begin
   // удалить предыдущую нажатую кнопку
   call DeletePressButton;

   //создать на месте удаленной кнопки новую кнопку (закрыть дыру)
   if btn_all then         call Create_btn_all("off", 0);
   else if btn_armor then  call Create_btn_armor("off", 0);
   else if btn_weapon then call Create_btn_weapon("off", 0);
   else if btn_ammo then   call Create_btn_ammo("off", 0);
   else if btn_drug then   call Create_btn_drug("off", 0);
   else if btn_tool then   call Create_btn_tool("off", 0);
   else if btn_misc then   call Create_btn_misc("off", 0);

end

procedure create_btn_trd_sub begin
   // удалить предыдущую нажатую кнопку
   call DeletePressButtonTrd;

   //создать на месте удаленной кнопки новую кнопку (закрыть дыру)
   if btn_trd_all then         call Create_btn_all("off", 1);
   else if btn_trd_armor then  call Create_btn_armor("off", 1);
   else if btn_trd_weapon then call Create_btn_weapon("off", 1);
   else if btn_trd_ammo then   call Create_btn_ammo("off", 1);
   else if btn_trd_drug then   call Create_btn_drug("off", 1);
   else if btn_trd_tool then   call Create_btn_tool("off", 1);
   else if btn_trd_misc then   call Create_btn_misc("off", 1);

end

procedure Create_btn_all(variable flag, variable trd) begin
   call subCreateButton("all", flag, trd, 0);

   if not(trd) then begin
       if flag == "on" then btn_all := true; else btn_all := false;
   end else if flag == "on" then btn_trd_all := true; else btn_trd_all := false;
end

procedure Create_btn_armor(variable flag, variable trd) begin
   call subCreateButton("armor", flag, trd, 1);

   if not(trd) then begin
      if flag == "on" then btn_armor := true; else btn_armor := false;
   end else if flag == "on" then btn_trd_armor := true; else btn_trd_armor :=false;
end

procedure Create_btn_weapon(variable flag, variable trd) begin
   call subCreateButton("weapon", flag, trd, 2);

   if not(trd) then begin
       if flag == "on" then btn_weapon := true; else btn_weapon := false;
   end else if flag == "on" then btn_trd_weapon := true; else btn_trd_weapon := false;
end

procedure Create_btn_ammo(variable flag, variable trd) begin
   call subCreateButton("ammo", flag, trd, 3);

   if not(trd) then begin
       if flag == "on" then btn_ammo := true; else btn_ammo := false;
   end else if flag == "on" then btn_trd_ammo := true; else btn_trd_ammo := false;
end

procedure Create_btn_drug(variable flag, variable trd) begin
   call subCreateButton("drug", flag, trd, 4);

   if not(trd) then begin
       if flag == "on" then btn_drug := true; else btn_drug := false;
   end else if flag == "on" then btn_trd_drug := true; else btn_trd_drug := false;
end

procedure Create_btn_tool(variable flag, variable trd) begin
   call subCreateButton("tool", flag, trd, 5);

   if not(trd) then begin
       if flag == "on" then btn_tool := true; else btn_tool := false;
   end else if flag == "on" then btn_trd_tool := true; else btn_trd_tool := false;
end

procedure Create_btn_misc(variable flag, variable trd) begin
   call subCreateButton("misc", flag, trd, 6);

   if not(trd) then begin
       if flag == "on" then btn_misc := true; else btn_misc := false;
   end else if flag == "on" then btn_trd_misc := true; else btn_trd_misc := false;
end

procedure subCreateButton(variable btn, variable flag, variable trd, variable vshift) begin
   variable btn_name, btn_on, btn_off, btn_hover;

   btn_name  := "filter_" + btn + "_" + flag + trd;
   btn_on    := buttonPCXFile + btn + "_on.pcx";
   btn_off   := buttonPCXFile + btn + "_" + flag + ".pcx";
   btn_hover := buttonPCXFile + btn + "_hover_" + flag + ".pcx";

   addButton(btn_name, xPos, 1 + yPos + (btnHeight * vshift), btnWidth, bHeight);
   addButtonGfx(btn_name, btn_on, btn_off, btn_hover);
end

procedure HightlightButton(variable btn, variable flag, variable trd) begin
   variable btn_name, btn_on, btn_hover;

   btn_name  := "filter_" + btn + "_" + flag + trd;
   btn_on    := buttonPCXFile + btn + "_on.pcx";
   btn_hover := buttonPCXFile + btn + "_hover_on.pcx";

   selectWin("inven_filter");
   AddButtonGFX(btn_name, btn_on, btn_on, btn_hover);
end

procedure DeletePressButton begin
variable btn;

   if btn_all then         btn := "all";
   else if btn_armor then  btn := "armor";
   else if btn_weapon then btn := "weapon";
   else if btn_ammo then   btn := "ammo";
   else if btn_drug then   btn := "drug";
   else if btn_tool then   btn := "tool";
   else if btn_misc then   btn := "misc";
   else return;

   call subDeleteButton(btn, "on", false);
end

procedure DeletePressButtonTrd begin
variable btn;

   if btn_trd_all then         btn := "all";
   else if btn_trd_armor then  btn := "armor";
   else if btn_trd_weapon then btn := "weapon";
   else if btn_trd_ammo then   btn := "ammo";
   else if btn_trd_drug then   btn := "drug";
   else if btn_trd_tool then   btn := "tool";
   else if btn_trd_misc then   btn := "misc";
   else return;

   call subDeleteButton(btn, "on", true);
end

procedure subDeleteButton(variable btn, variable type, variable flag) begin
   deleteButton("filter_" + btn + "_" + type + flag);
end

/////////////////////////////////////// WEIGHT ///////////////////////////////////////////

procedure refresh_pc_weight begin
   variable equp, item;
   DTRACE("refresh_pc_weight")

   item := critter_inven_obj(dude_obj, INVEN_TYPE_WORN);
   if (item) then equp := item_weight(item);

   item := critter_inven_obj2(dude_obj, INVEN_TYPE_LEFT_HAND);
   if (item) then equp += item_weight(item);

   item := critter_inven_obj2(dude_obj, INVEN_TYPE_RIGHT_HAND);
   if (item) then equp += item_weight(item);

   call weight_win(who_carry_amount(dude_obj) - equp, 0);
end

procedure weight_win(variable weight, variable type) begin
   DTRACE("weight_win")

   //создание окна для отображения веса предметов для игрока
   if (inven_weight == false) then begin
      create_win_flag("inven_weight", weight_win_x, weight_win_y, 60, 20, win_flags);
      selectWin("inven_weight");
      inven_weight := true;
   end
   else if (type == -1) then begin
      DeleteWin("inven_weight");
      inven_weight := false;
      return;
   end
   else begin
      selectWin("inven_weight");
      sfall_func0("win_fill_color");
   end

   variable wMax := swapMaxWeight if (swapMaxWeight != -1) else dude_max_weight;

   SetFont(101);
   if (current_swap_number > 0) then begin
      weight += who_carry_amount(swap_ptr); // swap-critter current equip items
      weight -= dudeEquipItemsWeight;
   end

   if (lootFilter andAlso crtTempBoxPC) then weight += who_carry_amount(crtTempBoxPC);

   if (weight > wMax) then
       SetTextColor(1.0, 0.1, 0.0); // red color
   else
       SetTextColor(r, g, b);

   if (lootFilter) then begin
      Format(weight + "/" + wMax, 0, 5, 60, 10, justifycenter);
   end else
      Format(mstr_inventry(30) + ": " + weight, 0, 8, 60, 10, justifycenter);

   showWin;
end

procedure weight_loot_win(variable obj) begin
   variable weight;
   DTRACE("weight_loot_win")

   // создание окна для отображения размера для контенеров
   if (inven_loot_weight == false) then begin
      create_win_flag("inven_loot_weight", r_weight_win_x, weight_win_y, 60, 20, win_flags);
      selectWin("inven_loot_weight");
      //AddRegion "tip" { 10,5, 50,5, 50,15, 10,15};
      //AddRegionProc("tip", ShowSize, HideSize, 0, 0);
      inven_loot_weight := true;
   end
   else begin
      selectWin("inven_loot_weight");
      sfall_func0("win_fill_color");
   end
   SetFont(101);

   if (obj_type(obj) == OBJ_TYPE_CRITTER) then begin
      weight = who_carry_amount(obj);
      if (crtTempBoxNPC) then weight += who_carry_amount(crtTempBoxNPC);
      call print_weight(weight, (npcMaxWeight if (npcExtraWeightStat != -1) else max_weight(obj)));
   end
   else begin
      // получает процент заполненности контейнера
      weight := get_current_inven_size(obj);
      if (crtTempBoxNPC) then weight += get_current_inven_size(crtTempBoxNPC);

      if (showPercentSize) then begin
         weight := round((weight / (containerMaxSize + 0.0)) * 100.0);
      end
      call print_weight(weight, 0);
   end
end

procedure barter_weight_win(variable weight) begin
   DTRACE("barter_weight_win")

   weight += who_carry_amount(dude_obj);
   if crtTempBoxPC then weight += who_carry_amount(crtTempBoxPC);
   if (tr_bTable) then weight += who_carry_amount(tr_bTable);

   //создание окна для отображения веса для игрока в бартере
   if (inven_weight == false) then begin
      create_win_flag("inven_weight", weight_win_x, weight_win_y, 60, 20, win_flags);
      inven_weight := true;
      selectWin("inven_weight");
   end
   else begin
      selectWin("inven_weight");
      sfall_func0("win_fill_color");
   end

   if (current_swap_number > 0) then begin
      weight += who_carry_amount(swap_ptr); // swap-critter current equip items
      weight -= dudeEquipItemsWeight;
   end

   call print_weight(weight, swapMaxWeight if (swapMaxWeight != -1) else dude_max_weight);
end

procedure party_weight_win(variable weight) begin
   DTRACE("party_weight_win")

   //создание окна для отображения веса у напарника во время обмена в бартере
   if (inven_party_weight == false) then begin
      create_win_flag("inven_party_weight", r_weight_win_x, weight_win_y, 60, 20, win_flags);
      selectWin("inven_party_weight");
      inven_party_weight := true;
   end
   else begin
      selectWin("inven_party_weight");
      sfall_func0("win_fill_color");
   end

   weight += who_carry_amount(dialogCritter);
   if (pc_bTable) then weight += who_carry_amount(pc_bTable);
   if (crtTempBoxNPC) then weight += who_carry_amount(crtTempBoxNPC);

   call print_weight(weight, partyMaxWeight);
end

// печатает текущий вес в текущее окно веса
procedure print_weight(variable weight, variable maxWeight) begin
   DTRACE("print_weight")

   if (maxWeight and weight > maxWeight) then
      SetTextColor(1.0, 0.1, 0.0);
   else
      SetTextColor(r, g, b);

   if (maxWeight) then
      Format(weight_cur_max, 0, 5, 60, 10, justifycenter);
   else begin
      if (showPercentSize) then
         Format(weight_percent, 0, 5, 60, 10, justifycenter);
      else begin
         maxWeight = containerMaxSize;
         Format(weight_cur_max, 0, 5, 60, 10, justifycenter);
      end
   end
   showWin;
end

procedure trader_cost_win begin
   //создание окна для отображения налички у торговца
   if (inven_caps == false) then begin
      create_win_flag("inven_caps", r_weight_win_x, weight_win_y, 60, 20, win_flags);
      selectWin("inven_caps");
      inven_caps := true;
   end
   else begin
      selectWin("inven_caps");
      sfall_func0("win_fill_color");
   end

   startcritical;
   SetTextColor(r, g, b);
   Format("$" + item_caps_total(dialogCritter), 0, 5, 60, 10, justifycenter);
   showWin;
   endcritical;
end

procedure hack_engine_weight(variable hack) begin
//   if (hack) then begin
//      _hack_weight := true;
//      write_byte(0x477EE1, 0xEB);
//   end
//   else begin
//      _hack_weight := false;
//      write_byte(0x477EE1, 0x75);
//   end
end

/////////////////////////////////////// EXCHANGE FEATURE ///////////////////////////////////////////

procedure GetAndSaveDudeWeight begin
   dudeBaseMaxWeight := get_pc_base_stat(STAT_carry_amt);
   dudeExtraMaxWeight := get_pc_extra_stat(STAT_carry_amt);
   dudeWeightBonus = GetDudeWeightBonus; // engine -/+ bonus
   swapMaxWeight = dude_max_weight;
end

procedure GetDudeWeightBonus begin
   variable bonus;
   set_pc_base_stat(STAT_carry_amt, 100);
   set_pc_extra_stat(STAT_carry_amt, 0);
   bonus = 100 - dude_max_weight;
   set_pc_base_stat(STAT_carry_amt, dudeBaseMaxWeight);
   set_pc_extra_stat(STAT_carry_amt, dudeExtraMaxWeight);
   return bonus; // возвращает положительное значение бонуса, если имеется движковое пенальти к максимальному весу
end

procedure SwappingParty(variable type, variable value) begin
   variable ptr, name, skip, flag, loop := true;
   variable currW, fid;

   DTRACE("SwappingParty")

   while (read_int(0x59E96C)) do begin // проверить открыты ли сумки
      call_offset_v2(0x476394, 2500, 2 + pcInBarter); //функция закрыть открытую сумку
   end

   ptr := swap_party_array[current_swap_number];
   name := obj_name(ptr);

   while (loop and current_swap_number > 0) do begin
      skip := false;
      flag := get_proto_data(obj_pid(ptr), PROTO_CR_FLAGS);
      if (flag bwand CFLG_BARTER) == false or (flag bwand CFLG_NOSTEAL) then skip := true;
      if skip or (tile_distance_objs(dude_obj, ptr) > 30) then begin
         if not(skip) then display_msg(name + get_ini_string(iniConfig + "MsgSwap"));
         current_swap_number += value;
         if (current_swap_number > len_party_array) then current_swap_number := 0;
         ptr := swap_party_array[current_swap_number];
         name := obj_name(ptr);
      end
      else loop := false;
   end

   if (swap_contaner == 0) then begin
      if (current_swap_number == 0) then return;
      swap_contaner := genericCrtBox;
      call MoveObjectInventory(dude_obj, swap_contaner, lootFilter); // перемещаем инвентарь игрока
      dudeEquipItemsWeight := who_carry_amount(dude_obj);  // вес экипированных вещей
   end

   debug_msg("Filter: Swapping with " + name);

   if (swap_ptr != 0) then begin
      if (swap_ptr == dude_obj and ptr != dude_obj) then begin
         call MoveObjectInventory(dude_obj, swap_contaner, lootFilter); // перемещаем инвентарь игрока
         dudeEquipItemsWeight := who_carry_amount(dude_obj);
      end
      else call MoveObjectInventory(dude_obj, swap_ptr, lootFilter); //возвращаем инвентарь партийца обратно
   end

   swap_ptr := ptr;
   if (swap_ptr == dude_obj) then begin
      move_obj_inven_to_obj(swap_contaner, dude_obj); //возвращаем инвентарь игрока обратно
   end
   else begin
      call MoveObjectInventory(swap_ptr, dude_obj, lootFilter);
   end

   // set carry
   if (swap_ptr != dude_obj) then begin
      call SetDudeSwapWeight(swap_ptr);
      swapMaxWeight := max_weight(swap_ptr); // максимальный подъемный вес криттера
   end
   else begin
      set_pc_base_stat(STAT_carry_amt, dudeBaseMaxWeight);
      set_pc_extra_stat(STAT_carry_amt, dudeExtraMaxWeight);
      swapMaxWeight := dude_max_weight;
   end

   if (type) then begin
      if (pcInBarter andAlso weightIsEnabled) then call barter_weight_win(0);
      call refresh_pc_interface_slots;
      call swap_name(name);
      showWin;
   end

   if (swap_ptr == dude_obj) then begin
      fid := get_object_data(dude_obj, 0x20);
   end
   else begin
      fid := obj_art_fid(swap_ptr);
      fid := (fid  bwand 0xFF00FFFF);
   end

   write_int(0x59E95C, fid); // i_fid
   if (value) then begin
      write_int(0x5190F8, 2); // set body rotation
      call_offset_v2(0x470650, -1, (2 + (pcInBarter))); /* display_body_ */
   end
end

procedure SetDudeSwapWeight(variable swapCritter) begin
   variable
      // максимальный подъемный вес криттера
      base = get_critter_base_stat(swapCritter, STAT_carry_amt),
      extra = get_critter_extra_stat(swapCritter, STAT_carry_amt),
      directWeight = base + extra - who_carry_amount(swapCritter); // минус текущий вес экипировки криттера

   set_critter_base_stat(swapCritter, STAT_carry_amt, 100);
   set_critter_extra_stat(swapCritter, STAT_carry_amt, 0);

   directWeight += max_weight(swapCritter) - 100; // учитываем возможный -/+ бонус движка

   set_critter_base_stat(swapCritter, STAT_carry_amt, base);
   set_critter_extra_stat(swapCritter, STAT_carry_amt, extra);

   // устанавливаем вес игроку в соответствии с характеристиками криттера
   set_pc_base_stat(STAT_carry_amt, dudeWeightBonus);
   set_pc_extra_stat(STAT_carry_amt, directWeight + dudeEquipItemsWeight);
end

procedure get_party_array(variable ptr_check) begin
   swap_party_array := party_member_list_critters;
   len_party_array := len_array(swap_party_array) - 1;
   if ((len_party_array < 1) or (is_in_array(ptr_check, swap_party_array))) then begin
      swap_party_array := 0;
      return 0;
   end
   fix_array(swap_party_array);

   current_swap_number := 0;
   return 1;
end

procedure swap_button_pressed(variable btn) begin
   if (isPressed == false) then begin
      isPressed := true;
      if (not(btn_all)) then begin
         if (pcInBarter) then begin
            dialog_message(get_ini_string(iniConfig + "MsgSwapFilter"));
         end
         else begin
            display_msg(get_ini_string(iniConfig + "MsgSwapFilter"));
         end
         play_sfx("IISXXXX1");
         return;
      end

      if (btn) then begin
          call next_swap_ptr;
      end
      else begin
          call back_swap_ptr;
      end
      play_sfx("IB2P1XX1");
      if (btn == 0) then btn--;

      if (swapMaxWeight == -1) then call GetAndSaveDudeWeight; // сохраняем статы веса игрока если еще не были сохранены
      call SwappingParty(true, btn);
   end
end

procedure next_swap_ptr begin
   current_swap_number++;
   if current_swap_number > len_party_array then current_swap_number := 0;
end

procedure back_swap_ptr begin
   current_swap_number--;
   if current_swap_number < 0 then current_swap_number := len_party_array;
end

procedure barter_swap_win begin
   if get_party_array(dialogCritter) then call create_swap_win(swap_brtr_win_x + swap_barter_offset, swap_brtr_win_y + swap_barter_y_offset);
end

procedure loot_swap_win begin
   SetFont(101);
   if get_party_array(lootObject) then call create_swap_win(swap_loot_win_x + swap_loot_offset, swap_loot_win_y + swap_loot_y_offset);
end

procedure create_swap_win(variable x_offset, variable y_offset) begin
   DTRACE("create_swap_win")

   swap_win_x := interfaceX + x_offset;
   swap_win_y := interfaceY + y_offset;

   create_win("swap_win", swap_win_x, swap_win_y, 150, 36);
   call swap_name(obj_name(dude_obj));

   AddButton("btn_next", 123, 9, 23, 20);
   AddButtonGFX("btn_next", "PCX\\InvFilterArt\\right_dn.pcx", "PCX\\InvFilterArt\\right_up.pcx", "");

   AddButton("btn_back", 4, 9, 23, 20);
   AddButtonGFX("btn_back", "PCX\\InvFilterArt\\left_dn.pcx", "PCX\\InvFilterArt\\left_up.pcx", "");

   showWin;
end

procedure swap_name(variable name) begin
   selectWin("swap_win");
   Display("PCX\\InvFilterArt\\swap_win.pcx");
   SetTextColor(1.0, 1.0, 1.0);
   Format(name, 0, 13, 150, 10, justifycenter);
end

procedure destroy_swap begin
   DeleteWin("swap_win");

   if (swap_contaner) then begin
      if (current_swap_number > 0) then begin
         current_swap_number := 0;
         call SwappingParty(false, 0);
      end
      destroy_object(swap_contaner);
   end
   swap_ptr := 0;
   swap_contaner := 0;
   current_swap_number := -1;

   if (swap_party_array) then begin
      free_array(swap_party_array);
      swap_party_array := 0;
   end
end

/////////////////////////////////////// DROP BUTTON ////////////////////////////////////////////////

procedure CreateDropAllBtn begin
   if ((obj_type(lootObject) == OBJ_TYPE_CRITTER                        // объект является криттером
      and has_trait(TRAIT_OBJECT, lootObject, OBJECT_TEAM_NUM) != 0     // и криттер не относится к команде игрока
      and (critter_state(lootObject) != CRITTER_IS_DEAD)                // и он не мертв, то выход
      /*orElse (get_proto_data(obj_pid(lootObject), PROTO_CR_FLAGS) bwand CFLG_NOSTEAL)*/)) then  // или криттер мертв и уст. флаг, то выход
   begin
      return;
   end

   create_win("drop_win", interfaceX + 70, interfaceY + 201, 40, 40);
   selectWin("drop_win");
   AddButton("btn_drop", 0, 0, 40, 40);

   if (btnGiveAll and (obj_type(lootObject) == OBJ_TYPE_CRITTER and critter_state(lootObject) != CRITTER_IS_DEAD)) then
      AddButtonGFX("btn_drop", "PCX\\InvFilterArt\\GiveAll_Dn.pcx", "PCX\\InvFilterArt\\GiveAll_Up.pcx", "");
   else
      AddButtonGFX("btn_drop", "PCX\\InvFilterArt\\DropAll_Dn.pcx", "PCX\\InvFilterArt\\DropAll_Up.pcx", "");
   showWin;

   AddButtonProc("btn_drop", key_drop_null, key_drop_null, key_drop_press, key_drop_release);
   dropButtonWin := true;
end

procedure check_dude_equp_items(variable isWeight) begin
   variable item, i, size = 0; // TODO: баг при декомпиляции отсутствует объявление переменной size

   for (i := INVEN_TYPE_WORN; i <= INVEN_TYPE_LEFT_HAND; i++) begin
      item := critter_inven_obj2(dude_obj, i);
      if (item == 0) then continue;
      if (isWeight) then
         size += item_weight(item);
      else
         size += proto_data(obj_pid(item), it_size);
   end
   return size;
end

critical procedure key_drop_press begin
   variable cSize, dSize, maxSize, isWeight;
   DTRACE("key_drop_press")

   if (dropPress == 0) then begin
      play_sfx("IB1P1XX1");
      dropPress := 1;
   end

   if (dropPress == 2 orElse get_object_data(dude_obj, 0x2C) <= 0) then return; // check dude inventory empty
   dropPress := 2;

   variable object = loot_obj;
   isWeight := (obj_item_subtype(object) != item_type_container);
   if isWeight then begin
      dSize := who_carry_amount(dude_obj);
      cSize := who_carry_amount(object);
      maxSize := max_weight(object);
   end
   else begin
      dSize := get_current_inven_size(dude_obj);
      cSize := get_current_inven_size(object);
      maxSize := get_proto_data(obj_pid(object), PROTO_CN_MAX_SIZE);
   end

   dSize -= check_dude_equp_items(isWeight); // check equp item
   if (dSize > (maxSize - cSize)) then begin
      create_message_window(mstr_inventry(26));
      return;
   end

   call MoveObjectInventory(dude_obj, object, false);
   sfall_func0("inventory_redraw");
end

procedure key_drop_null begin
   dropPress := 0;
end

procedure key_drop_release begin
   dropPress := 0;
   play_sfx("IB1LU1X1");
end

procedure ShowSize begin
   create_win("tipw", get_mouse_x + 15, get_mouse_y + 15 , 75, 20);
   selectWin("tipw");
   FillWin(0, 0, 0);
   ShowWin;
   debug_msg("ShowSize");
end

procedure HideSize begin
   DeleteWin("tipw");
   debug_msg("HideSize");
end
